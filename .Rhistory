library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
geo_coded <- pg_foreclosures_filtered |>
mutate(geo_data = geocode(location))
install.packages("httr")
library(httr)
install.packages("httr")
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
##install.packages("ggrepel")
##install.packages('ggthemes')
install.packages("ggmap")
library(tidyverse)
library(lubridate)
library(janitor)
library(ggthemes)
library(tidycensus)
library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
# Define your API key
api_key <- "8efce88f8d41d361a0ab0045b4131f78ee063fb6"
# Define a function to geocode addresses using the Census Geocoder API
geocode_addresses <- function(addresses) {
base_url <- "https://geocoding.geo.census.gov/geocoder/locations/addressbatch"
# Construct the API request
request <- POST(base_url,
query = list(format = "json", benchmark = "Public_AR_Current", vintage = "Current_Current", layers = "14"),
body = list(addresses = addresses),
encode = "csv")
# Add API key to the request header
request <- add_headers("Authorization" = paste0("Bearer ", api_key))
# Send the API request
response <- content(request)
return(response)
}
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
# Install and load the httr package
if (!require("httr")) {
install.packages("httr")
}
library(httr)
# Define your API key
api_key <- "8efce88f8d41d361a0ab0045b4131f78ee063fb6"
# Define a function to geocode addresses using the Census Geocoder API
geocode_addresses <- function(addresses) {
base_url <- "https://geocoding.geo.census.gov/geocoder/locations/addressbatch"
# Construct the API request
request <- httr::POST(base_url,
query = list(format = "json", benchmark = "Public_AR_Current", vintage = "Current_Current", layers = "14"),
body = list(addresses = addresses),
encode = "json")
# Add API key to the request header
request <- httr::add_headers(request, "Authorization" = paste0("Bearer ", api_key))
# Send the API request
response <- httr::content(request)
return(response)
}
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
# Install and load the httr package
if (!require("httr")) {
install.packages("httr")
}
library(httr)
# Define your API key
api_key <- "8efce88f8d41d361a0ab0045b4131f78ee063fb6"
# Define a function to geocode addresses using the Census Geocoder API
geocode_addresses <- function(addresses) {
base_url <- "https://geocoding.geo.census.gov/geocoder/locations/addressbatch"
# Construct the API request
request <- POST(base_url,
query = list(format = "json", benchmark = "Public_AR_Current", vintage = "Current_Current", layers = "14"),
body = list(addresses = addresses),
encode = "json")
# Add API key to the request headers
request <- add_headers(request, Authorization = paste0("Bearer ", api_key))
# Send the API request
response <- content(request)
return(response)
}
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
# Install and load the httr package
if (!require("httr")) {
install.packages("httr")
}
library(httr)
# Define your API key
api_key <- "8efce88f8d41d361a0ab0045b4131f78ee063fb6"
# Define a function to geocode addresses using the Census Geocoder API
geocode_addresses <- function(addresses) {
base_url <- "https://geocoding.geo.census.gov/geocoder/locations/addressbatch"
# Construct the API request
request <- POST(base_url,
query = list(format = "json", benchmark = "Public_AR_Current", vintage = "Current_Current", layers = "14"),
body = list(addresses = addresses),
encode = "json")
# Set API key in request headers
config(request, add_headers("Authorization" = paste("Bearer", api_key)))
# Send the API request
response <- content(request)
return(response)
}
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
# Extract census tract IDs from the response
# Note: The structure of the response may vary based on the API endpoint and parameters used
# You'll need to inspect the response structure to extract the relevant information
census_tract_ids <- sapply(geocoded_data$result$addressMatches, function(x) x$geographies$'Census Tracts'$TRACT)
# Add census tract IDs as a new column to pg_foreclosures_filtered
pg_foreclosures_filtered$census_tract_id <- census_tract_ids
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
census_tract_ids <- sapply(geocoded_data$result$addressMatches, function(x) {
if (length(x$geographies$'Census Tracts'$TRACT) > 0) {
return(x$geographies$'Census Tracts'$TRACT)
} else {
return(NA)  # Handle cases where census tract ID is not available
}
})
# Check if the length of census_tract_ids matches the number of rows in pg_foreclosures_filtered
if (length(census_tract_ids) == nrow(pg_foreclosures_filtered)) {
# Add census tract IDs as a new column to pg_foreclosures_filtered
pg_foreclosures_filtered$census_tract_id <- census_tract_ids
} else {
print("Error: Length of census_tract_ids does not match the number of rows in pg_foreclosures_filtered")
}
# Create a data frame with valid geocoded addresses and their census tract IDs
valid_geocoded_data <- data.frame(address = addresses, census_tract_id = census_tract_ids, stringsAsFactors = FALSE)
# Filter out NA census tract IDs
valid_geocoded_data <- data.frame(address = addresses[!is.na(census_tract_ids)],
census_tract_id = census_tract_ids[!is.na(census_tract_ids)],
stringsAsFactors = FALSE)
# Merge the valid geocoded data back into pg_foreclosures_filtered based on the address column
pg_foreclosures_filtered <- merge(pg_foreclosures_filtered, valid_geocoded_data, by = "address", all.x = TRUE)
# Filter out NA census tract IDs
valid_geocoded_data <- data.frame(address = addresses[!is.na(census_tract_ids)],
census_tract_id = census_tract_ids[!is.na(census_tract_ids)],
stringsAsFactors = FALSE)
# Merge the valid geocoded data back into pg_foreclosures_filtered based on the address column
pg_foreclosures_filtered <- merge(pg_foreclosures_filtered, valid_geocoded_data, by = "location", all.x = TRUE)
# Filter out NA census tract IDs
valid_geocoded_data <- data.frame(address = addresses[!is.na(census_tract_ids)],
census_tract_id = census_tract_ids[!is.na(census_tract_ids)],
stringsAsFactors = FALSE)
# Ensure 'pg_foreclosures_filtered' has a unique identifier column
pg_foreclosures_filtered$id <- seq_len(nrow(pg_foreclosures_filtered))
# Ensure 'valid_geocoded_data' has a unique identifier column
valid_geocoded_data$id <- seq_len(nrow(valid_geocoded_data))
# Merge the valid geocoded data back into pg_foreclosures_filtered based on the unique identifier column
pg_foreclosures_filtered <- merge(pg_foreclosures_filtered, valid_geocoded_data, by = "id", all.x = TRUE)
# Remove redundant columns and clean up if needed
pg_foreclosures_filtered <- subset(pg_foreclosures_filtered, select = -c(address))
# Remove the census_tract_id.y column if needed
pg_foreclosures_filtered <- subset(pg_foreclosures_filtered, select = -c(census_tract_id.y))
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
# Extract census tract IDs from the response
# Note: The structure of the response may vary based on the API endpoint and parameters used
# You'll need to inspect the response structure to extract the relevant information
census_tract_ids <- sapply(geocoded_data$result$addressMatches, function(x) {
if (length(x$geographies$'Census Tracts'$TRACT) > 0) {
return(x$geographies$'Census Tracts'$TRACT)
} else {
return(NA)  # Handle cases where census tract ID is not available
}
})
# Filter out NA census tract IDs
valid_geocoded_data <- data.frame(address = addresses[!is.na(census_tract_ids)],
census_tract_id = census_tract_ids[!is.na(census_tract_ids)],
stringsAsFactors = FALSE)
# Ensure 'pg_foreclosures_filtered' has a unique identifier column
pg_foreclosures_filtered$id <- seq_len(nrow(pg_foreclosures_filtered))
# Ensure 'valid_geocoded_data' has a unique identifier column
valid_geocoded_data$id <- seq_len(nrow(valid_geocoded_data))
# Merge the valid geocoded data back into pg_foreclosures_filtered based on the unique identifier column
merged_data <- merge(pg_foreclosures_filtered, valid_geocoded_data, by = "id", all.x = TRUE)
# Clean up column names
names(merged_data) <- make.names(names(merged_data), unique=TRUE)
# Remove redundant columns and clean up if needed
pg_foreclosures_filtered <- subset(merged_data, select = -c(address, id))
# Ensure only one census tract ID column remains
pg_foreclosures_filtered$census_tract_id <- ifelse(is.na(pg_foreclosures_filtered$census_tract_id.x),
pg_foreclosures_filtered$census_tract_id.y,
pg_foreclosures_filtered$census_tract_id.x)
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
# Extract census tract IDs from the response
# Note: The structure of the response may vary based on the API endpoint and parameters used
# You'll need to inspect the response structure to extract the relevant information
census_tract_ids <- sapply(geocoded_data$result$addressMatches, function(x) {
if (length(x$geographies$'Census Tracts'$TRACT) > 0) {
return(x$geographies$'Census Tracts'$TRACT)
} else {
return(NA)  # Handle cases where census tract ID is not available
}
})
# Filter out NA census tract IDs
valid_geocoded_data <- data.frame(address = addresses[!is.na(census_tract_ids)],
census_tract_id = census_tract_ids[!is.na(census_tract_ids)],
stringsAsFactors = FALSE)
# Ensure 'pg_foreclosures_filtered' has a unique identifier column
pg_foreclosures_filtered$id <- seq_len(nrow(pg_foreclosures_filtered))
# Ensure 'valid_geocoded_data' has a unique identifier column
valid_geocoded_data$id <- seq_len(nrow(valid_geocoded_data))
# Merge the valid geocoded data back into pg_foreclosures_filtered based on the unique identifier column
merged_data <- merge(pg_foreclosures_filtered, valid_geocoded_data, by = "id", all.x = TRUE)
# Clean up column names
names(merged_data) <- make.names(names(merged_data), unique=TRUE)
# Remove redundant columns and clean up if needed
pg_foreclosures_filtered <- subset(merged_data, select = -c(address, id))
# Ensure only one census tract ID column remains
pg_foreclosures_filtered$census_tract_id <- ifelse(is.na(pg_foreclosures_filtered$census_tract_id.x),
pg_foreclosures_filtered$census_tract_id.y,
pg_foreclosures_filtered$census_tract_id.x)
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
# Extract census tract IDs from the response
# Note: The structure of the response may vary based on the API endpoint and parameters used
# You'll need to inspect the response structure to extract the relevant information
census_tract_ids <- sapply(geocoded_data$result$addressMatches, function(x) {
if (length(x$geographies$'Census Tracts'$TRACT) > 0) {
return(x$geographies$'Census Tracts'$TRACT)
} else {
return(NA)  # Handle cases where census tract ID is not available
}
})
# Filter out NA census tract IDs
valid_geocoded_data <- data.frame(address = addresses[!is.na(census_tract_ids)],
census_tract_id = census_tract_ids[!is.na(census_tract_ids)],
stringsAsFactors = FALSE)
# Ensure 'pg_foreclosures_filtered' has a unique identifier column
pg_foreclosures_filtered$id <- seq_len(nrow(pg_foreclosures_filtered))
# Ensure 'valid_geocoded_data' has a unique identifier column
valid_geocoded_data$id <- seq_len(nrow(valid_geocoded_data))
# Merge the valid geocoded data back into pg_foreclosures_filtered based on the unique identifier column
merged_data <- merge(pg_foreclosures_filtered, valid_geocoded_data, by = "id", all.x = TRUE)
# Clean up column names
names(merged_data) <- make.names(names(merged_data), unique=TRUE)
# Remove redundant columns and clean up if needed
pg_foreclosures_filtered <- subset(merged_data, select = -c(address, id))
# Ensure only one census tract ID column remains
pg_foreclosures_filtered$census_tract_id <- ifelse(!is.na(pg_foreclosures_filtered$census_tract_id.x),
pg_foreclosures_filtered$census_tract_id.x,
pg_foreclosures_filtered$census_tract_id.y)
# Get addresses from the "location" column of pg_foreclosures_filtered
addresses <- pg_foreclosures_filtered$location
# Geocode the addresses
geocoded_data <- geocode_addresses(addresses)
# Extract census tract IDs from the response
census_tract_ids <- sapply(geocoded_data$result$addressMatches, function(x) {
if (length(x$geographies$'Census Tracts'$TRACT) > 0) {
return(x$geographies$'Census Tracts'$TRACT)
} else {
return(NA)  # Handle cases where census tract ID is not available
}
})
# Create a new data frame with the geocoded data
geocoded_df <- data.frame(location = addresses, census_tract_id = census_tract_ids)
View(valid_geocoded_data)
#install.packages("httr")
library(httr)
# Define your Geocodio API key
api_key <- "YOUR_API_KEY"
# Define function to geocode addresses using Geocodio API
geocode_addresses <- function(addresses) {
base_url <- "https://api.geocod.io/v1.6/geocode"
# Construct the API request
request <- POST(base_url,
query = list(api_key = api_key),
body = list(addresses = addresses),
encode = "json")
# Send the API request
response <- content(request)
return(response)
}
# Example usage:
addresses <- c("1600 Pennsylvania Ave NW, Washington, DC 20500", "123 Main St, Anytown, USA")
geocoded_data <- geocode_addresses(addresses)
View(geocoded_data)
#install.packages("httr")
library(httr)
# Define your Geocodio API key
api_key <- "0694009ddaa4600365d605a6553a4362923a42a"
# Define function to geocode addresses using Geocodio API
geocode_addresses <- function(addresses) {
base_url <- "https://api.geocod.io/v1.6/geocode"
# Construct the API request
request <- POST(base_url,
query = list(api_key = api_key),
body = list(addresses = addresses),
encode = "json")
# Send the API request
response <- content(request)
return(response)
}
# Example usage:
addresses <- c("1600 Pennsylvania Ave NW, Washington, DC 20500", "123 Main St, Anytown, USA")
geocoded_data <- geocode_addresses(addresses)
View(geocoded_data)
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
##install.packages("ggrepel")
##install.packages('ggthemes')
library(tidyverse)
library(lubridate)
library(janitor)
library(ggthemes)
library(tidycensus)
library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677)
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
##install.packages("ggrepel")
##install.packages('ggthemes')
library(tidyverse)
library(lubridate)
library(janitor)
library(ggthemes)
library(tidycensus)
library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
install.packages("httr")
library(httr)
install.packages("httr")
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
##install.packages("ggrepel")
##install.packages('ggthemes')
library(tidyverse)
library(lubridate)
library(janitor)
library(ggthemes)
library(tidycensus)
library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
foreclosure_pg <- read_csv("datasets/pg_foreclosures.csv", guess_max = 71677)
pg_foreclosures_filtered <- na.omit(foreclosure_pg[!is.na(foreclosure_pg$zip_code), ])
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677)
View(foreclosure_pg_census_tracts)
foreclosure_pg <- read_csv("datasets/pg_foreclosures.csv", guess_max = 71677)
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677)
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677) |>
clean_names()
num_unique <- length(unique(foreclosure_pg_census_tracts$census_tract_code))
num_unique <- length(unique(foreclosure_pg_census_tracts$census_tract_code))
print(num_unique)
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677) |>
clean_names()
tracts_unique <- length(unique(foreclosure_pg_census_tracts$census_tract_code))
print(tracts_unique)
pg_foreclosures_filtered <- na.omit(foreclosure_pg[!is.na(foreclosure_pg$zip_code), ])
# Perform inner join based on the 'location' column
pg_foreclosures_with_tracts <- inner_join(foreclosure_pg_census_tracts, foreclosures_pg, by = "location")
# Perform inner join based on the 'location' column
pg_foreclosures_with_tracts <- inner_join(foreclosure_pg_census_tracts, foreclosure_pg, by = "location")
# Print the merged dataset
print(pg_foreclosures_with_tracts)
View(pg_foreclosures_with_tracts)
pg_foreclosures_filtered <- na.omit(pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ])
View(pg_foreclosures_filtered)
View(pg_foreclosures_filtered)
pg_foreclosures_filtered <- na.omit(pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ]) |>
select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied)
pg_foreclosures_filtered <- na.omit(pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ])
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied)
View(pg_foreclosures_filtered)
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied, -city.y, -state.y)
pg_foreclosures_filtered <- na.omit(pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ])
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied, -city.y, -state.y)
View(pg_foreclosures_filtered)
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied, -city.y, -state.y, street_address)
pg_foreclosures_filtered <- na.omit(pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ])
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied, -city.y, -state.y, street_address)
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
##install.packages("ggrepel")
##install.packages('ggthemes')
library(tidyverse)
library(lubridate)
library(janitor)
library(ggthemes)
library(tidycensus)
library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
foreclosure_pg <- read_csv("datasets/pg_foreclosures.csv", guess_max = 71677)
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677) |>
clean_names()
tracts_unique <- length(unique(foreclosure_pg_census_tracts$census_tract_code))
print(tracts_unique)
# Perform inner join based on the 'location' column
pg_foreclosures_with_tracts <- inner_join(foreclosure_pg_census_tracts, foreclosure_pg, by = "location")
# Print the merged dataset
print(pg_foreclosures_with_tracts)
pg_foreclosures_filtered <- na.omit(pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ])
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied, -city.y, -state.y, street_address)
View(pg_foreclosures_filtered)
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
##install.packages("ggrepel")
##install.packages('ggthemes')
library(tidyverse)
library(lubridate)
library(janitor)
library(ggthemes)
library(tidycensus)
library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
foreclosure_pg <- read_csv("datasets/pg_foreclosures.csv", guess_max = 71677)
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677) |>
clean_names()
tracts_unique <- length(unique(foreclosure_pg_census_tracts$census_tract_code))
print(tracts_unique)
# Perform inner join based on the 'location' column
pg_foreclosures_with_tracts <- left_join(foreclosure_pg_census_tracts, foreclosure_pg, by = "location")
# Print the merged dataset
print(pg_foreclosures_with_tracts)
pg_foreclosures_filtered <- na.omit(pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ])
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied, -city.y, -state.y, street_address)
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
##install.packages("ggrepel")
##install.packages('ggthemes')
library(tidyverse)
library(lubridate)
library(janitor)
library(ggthemes)
library(tidycensus)
library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
foreclosure_pg <- read_csv("datasets/pg_foreclosures.csv", guess_max = 71677)
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677) |>
clean_names()
tracts_unique <- length(unique(foreclosure_pg_census_tracts$census_tract_code))
print(tracts_unique)
# Perform inner join based on the 'location' column
pg_foreclosures_with_tracts <- right_join(foreclosure_pg_census_tracts, foreclosure_pg, by = "location")
# Print the merged dataset
print(pg_foreclosures_with_tracts)
pg_foreclosures_filtered <- na.omit(pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ])
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied, -city.y, -state.y, street_address)
View(foreclosure_pg_census_tracts)
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
##install.packages("ggrepel")
##install.packages('ggthemes')
library(tidyverse)
library(lubridate)
library(janitor)
library(ggthemes)
library(tidycensus)
library(ggplot2)
library(ggrepel)
library(tigris)
library(sf)
library(ggmap)
foreclosure_pg <- read_csv("datasets/pg_foreclosures.csv", guess_max = 71677)
foreclosure_pg_census_tracts <- read_csv("datasets/pg_foreclosure_tract_geocodio.csv", guess_max = 71677) |>
clean_names()
tracts_unique <- length(unique(foreclosure_pg_census_tracts$census_tract_code))
print(tracts_unique)
# Perform inner join based on the 'location' column
pg_foreclosures_with_tracts <- left_join(foreclosure_pg_census_tracts, foreclosure_pg, by = "location")
# Print the merged dataset
print(pg_foreclosures_with_tracts)
View(pg_foreclosures_with_tracts)
pg_foreclosures_filtered <- pg_foreclosures_with_tracts[!is.na(pg_foreclosures_with_tracts$census_tract_code), ]
View(pg_foreclosures_filtered)
pg_foreclosures_filtered <- select(pg_foreclosures_filtered, -accuracy_score, -accuracy_type, -source, -full_fips_block, -metro_micro_statistical_area_name,-metro_micro_statistical_area_code, -metro_micro_statistical_area_type, -combined_statistical_area_name, -metropolitan_division_area_name, -metropolitan_division_area_code, -addressoccupied, -city.y, -state.y, street_address, -full_fips_block)
View(foreclosure_pg)
